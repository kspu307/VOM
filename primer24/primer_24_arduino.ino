#include <TimerOne.h> // подключаем библиотеку TimerOne для задействования функций Таймера1 
#define arrSize 32                           // размер массива оцифрованных значений сигнала ЭКГ для поиска в нем максимума и минимума сигнала
#define threshold 220                        // пороговое значение для определение наличия зубца R (требует подстройки под конкретного человека)
double sData = 0;                            // амплитуда размаха ЭКГ-сигнала
int val[arrSize];                            // массив для хранения оцифрованных значений ЭКГ-сигнала
int i = 0;                                   // переменная-счетчик 
int ecg = 0;                                 // переменная для хранения оцифрованного значения сигнала  
int maxV = 0, minV = 0;                      // переменные для хранения максимального и минимального значений ЭКГ-сигнала в массиве val[] 
int num_of_beats = 0;
// функция setup вызывается однократно при запуске Arduino
void setup() {
  Serial.begin(115200);                      // инициализируем Serial-порт на скорости 115200 Кбит/c. 
  Timer1.initialize(3000);                   // инициализируем Таймер1, аргументом указываем интервал срабатывания - 3000 микросекунд 
                                             // (1 000 000 микросекунд = 1 сек)
  Timer1.attachInterrupt(sendData);          // как только проходит 3000 микросекунд - наступает прерывание (вызывается функция sendData)
 // заполняем все элементы массива val[] нулями
 for (int k = 0; k < arrSize; k++){
   val[k] = 0;
 }
}
void sendData() {
  ecg = analogRead(A1);                       // записываем в переменную eсg оцифрованное значение сигнала с ножки А1 на Arduino.
  val[i] = map(ecg, 0, 1023, 0, 255);         // записываем в элемент массива val[i] переменную ecg, предварительно отнормированную на диапазон значений от 0 до 255,
  //Serial.write("A1");                       // записываем в Serial-порт имя поля в программе для визуализации, куда надо выводить сигнал
  //Serial.write(val[i]);                     // отправляем результат оцифровки
                      
  i++;                                        // инкрементируем (увеличиваем на 1) значение переменной-счетчика
  if (i == arrSize) {                         // если полностью заполнили массив
    i = 0;                                    // сбрасываем значение переменной-счетчика в 0
    
    // Ищем максимальное и минимальное значение ЭКГ-сигнала в массиве val[] 
    for (int k = 0; k < arrSize; k++) {       // создаем цикл for c переменной-итератором k и начинаем перебирать элементы массива val[]
      if (val[k] > maxV)                      // если элемент массива val[k] больше, чем значение ранее записанное в переменной для хранения максимумов maxV,
        maxV = val[k];                        // обновляем значение maxV
      if (val[k] < minV)                      // если же элемент массива val[k] меньше, чем значение ранее записанное в переменной для хранения минимумов minV,
        minV = val[k];                        // обновляем значение minV
    }
    sData = maxV - minV;                      // определяем максимальный размах сигнала ЭКГ, записанного в массив val[]
    maxV = 0;                                 // обнуляем значение переменной maxV, в которой хранится значение максимального элемента массива val[] 
    minV = 0;                                 // обнуляем значение переменной minV, в которой хранится значение минимального элемента массива val[] 
  }
  //Serial.println(sData); //убераем комментарий, чтобы подобрать значение порогового значения, глядя на график в плоттере по последоватльному соединению)
 
   if (sData > threshold) { // Если значение сигнала ЭКГ больше порогового значения, определенного эмпирически
     Serial.println(1);  //передаем в processing  "1"
  }
  else {
    Serial.println(0);  //передаем в processing "0"
  }  
}
void loop() {
// в бесконечном цикле мы ничего не делаем. Таймер1 сам будет вызывать функцию sendData через каждые 3000 микросекунд
}
